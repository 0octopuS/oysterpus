# Template

templeæ˜¯

- [class æ¨¡æ¿](#2-class-template)ï¼Œå¯èƒ½æ˜¯ nested classes
- [funtion æ¨¡æ¿](#3-function-template)ï¼Œå¯èƒ½æ˜¯æˆå‘˜å‡½æ•°
- [ç±»å‹åˆ«å](6.declarations.md#type-alias-alias-template)
- [ä¸€ç»„å˜é‡](#4-variable-template)
- ä¸€ç§concept

**ğŸ”˜ template-id**
id è¦ä¹ˆæ˜¯å‘½åäº†ä¸€ä¸ªæ¨¡æ¿ï¼ˆç§°ä¸º(simple-template-id)ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªé‡è½½æ“ä½œç¬¦æ¨¡æ¿æˆ–ç”¨æˆ·å®šä¹‰çš„å­—é¢æ¨¡æ¿çš„åç§°ã€‚

## 1. Template parameters and arguments

å‡½æ•°æ¨¡æ¿æœ‰ä»¥ä¸‹å‡ ç§å‚æ•°

- a non-type template parameter;
- a type template parameter;
- a template template parameter.

### 1.1 non-type template parameter

éç±»å‹çš„å‚æ•°é€šå¸¸æ˜¯ä¸€äº›åœ¨ç¼–è¯‘å™¨å°±èƒ½å†³å®šçš„ structural typeã€‚ä¾‹å¦‚ `<size_t N>` æ¥æŒ‡å®šæŸä¸ªå¤§å°ï¼Œæˆ–è€… `<int times>` æ¥å†³å®šæŸä¸ªå€¼çš„æ¨¡æ¿ç‰¹åŒ–ã€‚

**ğŸ”˜ `auto` ä½œä¸ºå ä½ç¬¦**
æŒ‰ç…§autoæ¨æ–­è§„åˆ™è¿›è¡Œæ¨æ–­ã€‚

```C++
template<auto n>
struct B { /* ... */ };
 
B<5> b1;   // OK: non-type template parameter type is int
B<'a'> b2; // OK: non-type template parameter type is char
B<2.5> b3; // error (until C++20): non-type template parameter type cannot be double
 
// C++20 deduced class type placeholder, class template arguments are deduced at the call site
template<std::array arr>
void f();
 
f<std::array<double, 8>{}>();
```

å¯¹äº pack parameter æ¥è¯´ï¼Œå°†ä¼šå¯¹æ¯ä¸ªç±»å‹è¿›è¡Œæ¨æ–­ã€‚

```C++
template<auto...>
struct C {};
 
C<'C', 0, 2L, nullptr> x; // OK
```

### 1.2 type template parameter

æœ€å¸¸è§çš„ï¼Œä½¿ç”¨ `class` æˆ– `typename` å…³é”®è¯è¿›è¡Œå£°æ˜ã€‚

**ğŸ”˜ å¯¹äº constraint å’Œ template çš„è§„åˆ™**
æ¯ä¸ªè¢«æ¦‚å¿µ `C` é™åˆ¶çš„å‚æ•° `P` ç§°ä¸ºç±»å‹é™åˆ¶ `Q`ï¼Œè¿™æ¡è¯­å¥å«é™åˆ¶è¡¨è¾¾å¼ `E`ï¼Œéµä»ä»¥ä¸‹è§„åˆ™ï¼š

- å¦‚æœ `Q` æ˜¯ `C`
  - `P` ä¸æ˜¯ä¸€ä¸ª parameter packï¼Œ `E` å°±æ˜¯ `C<P>`
  - å¦åˆ™ `P` æ˜¯ä¸€ä¸ªæŠ˜å è¡¨è¾¾å¼ `C<P> && ...`
- å¦‚æœ `Q` æ˜¯ `C<A1,A2...,AN>` ï¼Œé‚£ä¹ˆ `E` æ˜¯ `C<P,A1,A2...,AN>` æˆ–  `C<P,A1,A2...,AN> && ...`ã€‚

```C++
template<typename T>
concept C1 = true;
template<typename... Ts> // variadic concept
concept C2 = true;
template<typename T, typename U>
concept C3 = true;
 
template<C1 T>         struct s1; // constraint-expression is C1<T>
template<C1... T>      struct s2; // constraint-expression is (C1<T> && ...)
template<C2... T>      struct s3; // constraint-expression is (C2<T> && ...)
template<C3<int> T>    struct s4; // constraint-expression is C3<T, int>
template<C3<int>... T> struct s5; // constraint-expression is (C3<T, int> && ...)
```



```C++
template<class T>
class My_vector { /* ... */ }; 

template<class T = void>
class My_vector { /* ... */ }; // default å€¼ä¸º void

template<typename... T>
class My_tuple { /* ... */ }; // parameter pack

template<My_concept T>
class My_constrained_vector { /* ... */ }; // é™åˆ¶å‚æ•°ç±»å‹ï¼Œæ²¡æœ‰é»˜è®¤

template<My_concept T = void>
class My_constrained_op_functor { /* ... */ }; // é™åˆ¶å‚æ•°ç±»å‹ï¼Œä½†æœ‰é»˜è®¤

template<My_concept... Ts>
class My_constrained_tuple { /* ... */ }; // é™åˆ¶å‚æ•°ç±»å‹ + parameter pack
```

### 1.3 template template parameter

æ¥æ”¶ä¸€ä¸ªæ¨¡æ¿ä½œä¸ºå‚æ•°

```C++
template<typename T>
class my_array {};
 
// two type template parameters and one template template parameter:
template<typename K, typename V, template<typename> typename C = my_array>
class Map
{
    C<K> key;
    C<V> value;
};
```


## 2. Class template

## 3. Function template

### 3.1 Abbreviated function template

ç”¨ `auto` æ¥è‡ªåŠ¨ç”Ÿæˆæ¨¡æ¿ï¼Œè¿›è¡Œç±»å‹æ¨æ–­ã€‚

```C++
void f1(auto); // same as template<class T> void f1(T)
void f2(C1 auto); // same as template<C1 T> void f2(T), if C1 is a concept
void f3(C2 auto...); // same as template<C2... Ts> void f3(Ts...), if C2 is a concept
void f4(const C3 auto*, C4 auto&); // same as template<C3 T, C4 U> void f4(const T*, U&);
 
template<class T, C U>
void g(T x, U y, C auto z); // same as template<class T, C U, C W> void g(T x, U y, W z);
```
 

## 4. Variable template

ä¸€ä¸ª variable template å®šä¹‰äº†ä¸€ç³»åˆ—çš„å˜é‡æˆ–é™æ€æ•°æ®æˆå‘˜ã€‚

**ğŸ”˜ instantiated variable**
ä» variable template å®ä¾‹åŒ–çš„å˜é‡å«åš instantiated variableã€‚


```C++
template<class T>
constexpr T pi = T(3.1415926535897932385L); // variable template
 
template<class T>
T circular_area(T r) // function template
{
    return pi<T> * r * r; // pi<T> is a variable template instantiation
}
```

**ğŸ”˜ instantiated static data member**
ä» variable template å®ä¾‹åŒ–çš„é™æ€æ•°æ®æˆå‘˜å« instantiated static data memberã€‚

```C++
using namespace std::literals;
struct matrix_constants
{
    template<class T>
    using pauli = hermitian_matrix<T, 2>; // alias template
 
    template<class T> // static data member template
    static constexpr pauli<T> sigmaX = {{0, 1}, {1, 0}}; 
 
    template<class T>
    static constexpr pauli<T> sigmaY = {{0, -1i}, {1i, 0}};
 
    template<class T>
    static constexpr pauli<T> sigmaZ = {{1, 0}, {0, -1}};
};
```

## 5. Template argument deduction

åœ¨å¯èƒ½çš„æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šä»1.å‡½æ•°å‚æ•°ä¸­æ¨å¯¼å‡ºç¼ºå°‘çš„æ¨¡æ¿å‚æ•° 2. ä»constructorå‚æ•°æ¨æ–­ã€‚
ä»¥ä¸‹å‡½æ•°ç»™å®šäº† `To` çš„ç±»å‹ï¼Œè€Œ `From` çš„ç±»å‹æ˜¯ä»å‡½æ•°å‚æ•°ä¸­æ¨æ–­çš„ã€‚

```C++
template<typename To, typename From>
To convert(From f);
 
void g(double d) {
    int i = convert<int>(d);    // calls convert<int, double>(double)
    char c = convert<char>(d);  // calls convert<char, double>(double)
    int(*ptr)(float) = convert; // instantiates convert<int, float>(float) 
                                // and stores its address in ptr
}
```

åœ¨åˆå§‹åŒ–stdå®¹å™¨çš„æ—¶å€™å°±å¯ä»¥ç”¨ç±»å‹æ¨æ–­ã€‚

```C++
std::pair p(2, 4.5);
std::tuple t(4, 3, 2.5);
std::copy_n(vi1, 3, std::back_insert_iterator(vi2));
std::for_each(vi.begin(), vi.end(), Foo([&](int i) {...}));
auto lck = std::lock_guard(foo.mtx);
std::lock_guard lck2(foo.mtx, ul);
```

### Deduction from a type

é€šå¸¸æœ‰ `T, T*, T const*, T&, T const&, T&&, T const&&`è¿™å‡ ç§ç±»å‹ã€‚
åœ¨æ¨æ–­çš„æ—¶å€™åšreference collapse


## 6. Class template argument deduction


## 7. Explicit (full) template specialization

## 8. Partial template specialization

å±€éƒ¨ç‰¹åŒ–ï¼Œå…è®¸å¯¹æ¨¡æ¿ä¸­çš„éƒ¨åˆ†å‚æ•°åšæŒ‡å®šã€‚

- å¿…é¡»è¦æŒ‡æ˜æŸäº›ä¸œè¥¿ï¼Œä¸èƒ½å’ŒåŸæ¥çš„æ¨¡æ¿å®Œå…¨ç›¸åŒ
- ä¸èƒ½æœ‰é»˜è®¤å‚æ•°
- packä¸€å®šåœ¨æœ€å

```C++
template<class T1, class T2, int I>
class A {};             // primary template
template<class T, int I>
class A<T, T*, I> {};   // #1: partial specialization where T2 is a pointer to T1
template<class T, class T2, int I>
class A<T*, T2, I> {};  // #2: partial specialization where T1 is a pointer
template<class T>
class A<int, T*, 5> {}; // #3: partial specialization where
                        //     T1 is int, I is 5, and T2 is a pointer
template<class X, class T, int I>
class A<X, T*, I> {};   // #4: partial specialization where T2 is a pointer
```



## Dependent name - SFINAE

åœ¨æ¨¡æ¿ï¼ˆåŒ…æ‹¬ç±»æ¨¡æ¿å’Œå‡½æ•°æ¨¡æ¿ï¼‰çš„å®šä¹‰ä¸­ï¼Œä¸€äº›æ„é€ çš„å«ä¹‰å¯èƒ½åœ¨ä¸åŒçš„å®ä¾‹åŒ–ä¸­æœ‰æ‰€ä¸åŒã€‚ç‰¹åˆ«æ˜¯ï¼Œç±»å‹å’Œè¡¨è¾¾å¼å¯èƒ½**depend on**ç±»å‹æ¨¡æ¿å‚æ•°çš„ç±»å‹å’Œéç±»å‹æ¨¡æ¿å‚æ•°çš„å€¼ã€‚

```C++
template<typename T>
struct X : B<T> // "B<T>" is dependent on T
{
    typename T::A* pa; // "T::A" is dependent on T
 
    void f(B<T>* pb)
    {
        static int i = B<T>::i; // "B<T>::i" is dependent on T
        pb->j++; // "pb->j" is dependent on T
    }
};
```

å¯¹äº dependant names å’Œ non-dependant namesçš„Name lookup å’Œ binding è§„åˆ™æ˜¯ä¸åŒçš„ã€‚

### åœ¨declarationä¸­ç”¨`typename`æ¥è¡¨æ˜dependent names

åœ¨æ¨¡æ¿çš„å£°æ˜æˆ–å®šä¹‰ä¸­ï¼ŒåŒ…æ‹¬ alias templateï¼Œä¸€ä¸ª (ä¸æ˜¯å½“å‰å®ä¾‹åŒ–çš„æˆå‘˜) å¹¶ä¸” (ä¾èµ–äºæ¨¡æ¿å‚æ•°çš„åç§°) **ä¸è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªtype**ï¼Œé™¤éä½¿ç”¨å…³é”®å­—`typename` æˆ–è€…å®ƒå·²ç»è¢«ç¡®ç«‹ä¸ºä¸€ä¸ªç±»å‹åç§°ï¼Œä¾‹å¦‚é€šè¿‡typedefå£°æ˜æˆ–è€…è¢«ç”¨äºå‘½åä¸€ä¸ªåŸºç±»ã€‚

```C++
// åœ¨ç¬¬1é˜¶æ®µï¼Œç¼–è¯‘å™¨ä¸çŸ¥é“ T::size_type æ˜¯ä¸€ä¸ªç±»å‹ï¼Œ T::nposæ˜¯ä¸€ä¸ªå¸¸é‡ -> ç¬¬2é˜¶æ®µç‰¹ä¾‹åŒ–çš„æ—¶å€™çŸ¥é“
template <typename T> 
T :size_type munge(T const &a){
    T::size_type *i(T::npos);
    // å¦‚æœT::nposæ˜¯ä¸€ä¸ªç±»å‹ -> å‡½æ•°å£°æ˜
} // è¿™ä¸¤ä¸ªéƒ½æ˜¯ dependent name ï¼Œ å–å†³äºç±»å‹å‚æ•°T

template <typename T> 
typename T :size_type munge(T const &a){
    typename T::size_type *i(T::npos);
    // å¦‚æœT::nposæ˜¯ä¸€ä¸ªç±»å‹ -> å‡½æ•°å£°æ˜
} 
```

## variadic templates

