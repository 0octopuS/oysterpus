# 1. Value categories

æ¯ä¸ªC++è¡¨è¾¾å¼ï¼ˆä¸€ä¸ªæ“ä½œç¬¦åŠå…¶æ“ä½œæ•°ã€ä¸€ä¸ªå­—é¢æ„ä¹‰ã€ä¸€ä¸ªå˜é‡åç­‰ï¼‰éƒ½æœ‰ä¸¤ä¸ªç‹¬ç«‹çš„å±æ€§ï¼šä¸€ä¸ª type å’Œä¸€ä¸ª value category ã€‚æ¯ä¸ªè¡¨è¾¾å¼éƒ½æœ‰ä¸€äº›éå¼•ç”¨ç±»å‹ï¼Œè€Œä¸”æ¯ä¸ªè¡¨è¾¾å¼éƒ½æ­£å¥½å±äºä¸‰ä¸ªä¸»è¦çš„å€¼ç±»åˆ«ä¹‹ä¸€ï¼šprvalueã€xvalueå’Œlvalueã€‚

value category å®šä¹‰ 1. å®ƒçš„Lifetime 2. å®ƒçš„identity(ä¹Ÿå°±æ˜¯åœ°å€æ˜¯å¦å¯ç”¨)ã€‚


## Object

objectçš„å®šä¹‰å¦‚ä¸‹

!!! quote object  
    ä¸€ä¸ªobjectç±»å‹æ˜¯ä¸æ˜¯ä¸€ä¸ªå€¼ã€å¼•ç”¨ã€å‡½æ•°ã€æšä¸¾ã€ç±»å‹ã€non-static class æˆå‘˜ã€æ¨¡æ¿ã€classã€å‡½æ•°æ¨¡æ¿ç‰¹åŒ–ã€åç§°ç©ºé—´ã€å‚æ•°packå’Œthisã€‚
    > An object type is a (possibly-cv-qulified) type that is not a value, reference, function, enumerator, type, non-static class member, template, class or function template specialization, namespace, parameter pack, and this.
    ä¸€ä¸ª object æœ‰ size(`sizeof`), alignment requirement(`alignof`), storage duration(`automatic`, `static`, `dynamic`, `thread-local`), lifetime, type, value, (name)ã€‚



## Object lifetime

æ ‡å‡†ä¸­å¯¹äºæŸä¸ªobjectçš„**lifetimeå¼€å§‹**çš„è§„åˆ™æ˜¯ï¼š

1. å¯¹äºç±»å‹Tï¼Œå½“æœ‰ç€æ­£ç¡®çš„å¯¹é½å’Œå¤§å°çš„å­˜å‚¨ç©ºé—´è¢«è·å¾—çš„æ—¶å€™ã€‚
2. å¦‚æœobjectæœ‰ç€éç©ºçš„åˆå§‹åŒ–ï¼Œå½“åˆå§‹åŒ–å®Œæˆæ—¶åˆ™ç”Ÿå‘½å‘¨æœŸå¼€å§‹ã€‚ï¼ˆå¦‚æœè¯¥objectæ˜¯ä¸€ä¸ªunionæˆå‘˜æˆ–å…¶ä¸­çš„å­objectåˆ™ä¾‹å¤–ï¼‰ã€‚

æ ‡å‡†ä¸­å¯¹äºæŸä¸ªobjectçš„l**ifetimeç»“æŸ**çš„è§„åˆ™æ˜¯ï¼š
3. å¦‚æœTæ˜¯ä¸€ä¸ªclassç±»å‹ï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªéå¹³å‡¡çš„deconstructorï¼Œå½“deconstructorè¢«è°ƒç”¨å¼€å§‹æ—¶ã€‚
4. å½“objectæ‰€å æœ‰çš„å­˜å‚¨è¢«é‡Šæ”¾ï¼Œæˆ–è€…å…¶å­˜å‚¨è¢«å…¶ä»–ä¸åµŒå¥—åœ¨oä¸­çš„objecté‡ç”¨æ—¶ã€‚

## Scope

åœ¨C++ç¨‹åºä¸­å‡ºç°çš„æ¯ä¸ª name éƒ½åªåœ¨æºä»£ç çš„æŸä¸ªå¯èƒ½ä¸ç›¸å¹²çš„éƒ¨åˆ†å¯è§ï¼Œè¿™äº›éƒ¨åˆ†è¢«ç§°ä¸ºå®ƒçš„ scope ã€‚
åœ¨ä¸€ä¸ª scope ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ unqualified name lookup æ¥å°† name ä¸å®ƒçš„å£°æ˜è”ç³»èµ·æ¥ã€‚

**ğŸ”˜Block scope**
**ğŸ”˜Function parameter scope**
**ğŸ”˜Namespace scope**
**ğŸ”˜Class scope**
**ğŸ”˜Enumeration scope**
**ğŸ”˜Template parameter scope**
**ğŸ”˜Point of declaration**


## RAII

!!! Summary RAII
    èµ„æºåœ¨æŸä¸ªâ€œRAII classâ€çš„constructorä¸­è¢«è·å¾—ï¼Œåœ¨destructorä¸­è¢«å¤„ç†ã€‚
èµ„æºè·å–å³åˆå§‹åŒ–æˆ–RAIIï¼Œæ˜¯ä¸€ç§C++ç¼–ç¨‹æŠ€æœ¯ï¼Œå®ƒå°†ä½¿ç”¨å‰**å¿…é¡»è·å–çš„èµ„æº**ï¼ˆåˆ†é…çš„å †å†…å­˜ã€æ‰§è¡Œçº¿ç¨‹ã€å¼€æ”¾çš„å¥—æ¥å­—ã€å¼€æ”¾çš„æ–‡ä»¶ã€é”å®šçš„çªå˜ä½“ã€ç£ç›˜ç©ºé—´ã€æ•°æ®åº“è¿æ¥â€”â€”â€”â€”ä»»ä½•å­˜åœ¨æœ‰é™ä¾›åº”çš„ä¸œè¥¿ï¼‰**çš„ç”Ÿå‘½å‘¨æœŸ**ä¸**å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸ**ç»“åˆèµ·æ¥ã€‚

RAIIä¿è¯èµ„æºå¯¹ä»»ä½•å¯èƒ½è®¿é—®è¯¥å¯¹è±¡çš„å‡½æ•°éƒ½æ˜¯**å¯ç”¨çš„**ï¼ˆèµ„æºå¯ç”¨æ€§æ˜¯ä¸€ä¸ªç±»çš„ä¸å˜é‡ï¼Œæ¶ˆé™¤äº†å¤šä½™çš„è¿è¡Œæ—¶æµ‹è¯•ï¼‰ã€‚å®ƒè¿˜ä¿è¯æ‰€æœ‰çš„èµ„æºåœ¨å…¶æ§åˆ¶å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶ï¼ŒæŒ‰ç…§è·å–çš„**ç›¸åé¡ºåºè¢«é‡Šæ”¾**ã€‚åŒæ ·åœ°ï¼Œå¦‚æœèµ„æºè·å–å¤±è´¥ï¼ˆæ„é€ å‡½æ•°ä»¥å¼‚å¸¸é€€å‡ºï¼‰ï¼Œæ¯ä¸ªå®Œå…¨æ„é€ çš„æˆå‘˜å’ŒåŸºå­å¯¹è±¡æ‰€è·å–çš„æ‰€æœ‰èµ„æºéƒ½ä»¥åˆå§‹åŒ–çš„åå‘é¡ºåºé‡Šæ”¾ã€‚è¿™å°±åˆ©ç”¨äº†è¯­è¨€çš„æ ¸å¿ƒç‰¹æ€§ï¼ˆå¯¹è±¡å¯¿å‘½ã€èŒƒå›´é€€å‡ºã€åˆå§‹åŒ–é¡ºåºå’Œå †æ ˆå±•å¼€ï¼‰æ¥æ¶ˆé™¤èµ„æºæ³„æ¼ï¼Œä¿è¯å¼‚å¸¸å®‰å…¨ã€‚


**ğŸ”˜RAIIå¯ä»¥æ¦‚æ‹¬ä¸ºä»¥ä¸‹å†…å®¹ã€‚**

1. å°†æ¯ä¸ªèµ„æºå°è£…æˆä¸€ä¸ªç±»ï¼Œå…¶ä¸­
    - æ„é€ å‡½æ•°è·å–èµ„æºå¹¶å»ºç«‹æ‰€æœ‰ç±»çš„ä¸å˜æ€§ï¼Œå¦‚æœä¸èƒ½åšåˆ°ï¼Œåˆ™æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ã€‚
    - è§£æ„å‡½æ•°é‡Šæ”¾èµ„æºï¼Œå¹¶ä¸”ä¸æŠ›å‡ºå¼‚å¸¸ã€‚
2. å§‹ç»ˆé€šè¿‡RAIIç±»çš„ä¸€ä¸ªå®ä¾‹æ¥ä½¿ç”¨èµ„æºï¼Œè¯¥ç±»è¦ä¹ˆæ˜¯
    - è‡ªå·±æœ‰è‡ªåŠ¨å­˜å‚¨æ—¶é—´æˆ–ä¸´æ—¶å¯¿å‘½ï¼Œæˆ–
    - å¯¿å‘½å—è‡ªåŠ¨æˆ–ä¸´æ—¶å¯¹è±¡çš„å¯¿å‘½é™åˆ¶
3. Move è¯­ä¹‰ä½¿å¾—åœ¨å¯¹è±¡ä¹‹é—´ã€è·¨ä½œç”¨åŸŸã€çº¿ç¨‹å†…å¤–å®‰å…¨è½¬ç§»èµ„æºæ‰€æœ‰æƒæˆä¸ºå¯èƒ½ï¼ŒåŒæ—¶ä¿æŒèµ„æºå®‰å…¨ã€‚

**ğŸ”˜éRAII**
å…·æœ‰open()/close()ã€lock()/unlock()æˆ–init()/copyFrom()/destroy()æˆå‘˜å‡½æ•°çš„ç±»æ˜¯éRAIIç±»çš„å…¸å‹ä¾‹å­ã€‚

```C++
std::mutex m;
 
void bad() 
{
    m.lock();                    // acquire the mutex
    f();                         // å¦‚æœ f()æŠ›å‡ºå¼‚å¸¸, mutexæ°¸ä¸é‡Šæ”¾
    if(!everything_ok()) return; // early return, mutexæ°¸ä¸é‡Šæ”¾
    m.unlock();                  // å¦‚æœ bad() èµ°åˆ°è¿™ä¸€å¥, mutexé‡Šæ”¾
}
 
void good()
{
    std::lock_guard<std::mutex> lk(m); // RAII class: mutex acquisition is initialization
    f();                               // å¦‚æœ f()æŠ›å‡ºå¼‚å¸¸, mutexé‡Šæ”¾
    if(!everything_ok()) return;       // early return, mutexé‡Šæ”¾
}                                      // å¦‚æœ good() æ­£å¸¸è¿”å›, mutexé‡Šæ”¾
```

**ğŸ”˜ç”¨æˆ·è‡ªè¡Œç®¡ç†çš„stl RAII wrapper**
ä½¿ç”¨`std::unique_ptr` å’Œ `std::shared_ptr` æ¥ç®¡ç†åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼Œæˆ–è€…ç”¨æˆ·æä¾›çš„deleterï¼Œä»»ä½•ä½¿ç”¨ plain pinter å‘ˆç°çš„èµ„æºã€‚
`std::lock_guard, std::unique_lock, std:: shared_lock` æ¥ç®¡ç† mutexesã€‚

# Definitions and ODR (One Definition Rule)


```C++
template<typename T> // template declares, but doesn't define T
typedef S S2; // typedef declares, but doesn't define S2 (S may be incomplete)
using S2 = S; // alias declares, but doesn't define S2 (S may be incomplete)
using N::d; // using declares, but doesn't define d

extern template
f<int, char>; //  explicit instantiation declaration (an "extern template"), but doesn't define f<int, char>

template<>
struct A<int>; // explicit specialization, but doesn't define A<int>
```

**ğŸ”˜ ODR è§„åˆ™**

!!! Summary ODR
    1. å¯¹äºä¸€ä¸ªåœ¨æŸä¸ªç¿»è¯‘å•å…ƒä¸­ä½¿ç”¨ `inline` çš„ä¸œè¥¿ï¼ˆå˜é‡æˆ–å‡½æ•°ï¼‰ï¼Œå®ƒåœ¨è¯¥ç¿»è¯‘å•å…ƒä¸­**è‡³å°‘å®šä¹‰ä¸€æ¬¡**ã€‚
    2. å¯¹äºä¸€ä¸ªåœ¨æŸä¸ªç¿»è¯‘å•å…ƒä¸­ä½¿ç”¨çš„é `inline`ã€é `template` çš„ä¸œè¥¿ï¼Œå®ƒåœ¨è¯¥ç¿»è¯‘å•å…ƒä¸­ä»…**å®šä¹‰ä¸€æ¬¡**ã€‚
    3. å¯¹äºä¸€ä¸ª `template` ï¼Œåœ¨å¤´æ–‡ä»¶ä¸­**å®šä¹‰**å®ƒï¼Œéœ€è¦ä½¿ç”¨çš„æ—¶å€™åŒ…æ‹¬è¿™ä¸ªå¤´å””è§ï¼Œå¹¶è®©å·¥å…·é“¾å†³å®šå®ƒåœ¨å“ªé‡Œè¢«å®šä¹‰ã€‚ 


