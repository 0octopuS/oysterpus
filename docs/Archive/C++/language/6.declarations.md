# 1. Declarations Overview

**Declarations**æ˜¯åœ¨C++ç¨‹åºä¸­å¼•å…¥ï¼ˆæˆ–é‡æ–°å¼•å…¥ï¼‰**åç§°**çš„æ–¹å¼ã€‚å¹¶éæ‰€æœ‰çš„declarationséƒ½èƒ½å®é™…å£°æ˜ä»»ä½•ä¸œè¥¿ï¼Œæ¯ç§å®ä½“çš„å£°æ˜æ–¹å¼éƒ½ä¸åŒã€‚**Definitions**æ˜¯ä¸€ç§è¶³ä»¥ä½¿ç”¨åç§°æ‰€æ ‡è¯†çš„å®ä½“çš„**Declarations**ã€‚**Definition**éƒ½æ˜¯**Declarations**ï¼Œåè¿‡æ¥åˆ™ä¸æ˜¯ã€‚

```C++
int foo(int n); // declarations
int foo(int n) {return n + 5} // definition

int i; // definition, allocates storage
extern int j; // non-defining declaration("exists, but not here")
extern int k =42; // definition
```

ä¸åŒçš„åå­—å’Œä»–ä»¬çš„æ€§è´¨

|                  | object | function | label |
| ---------------- | ------ | -------- | ----- |
| scope            | yes    | yes      | yes   |
| type             | yes    | yes      | no    |
| storage duration | yes    | no       | no    |
| linkage          | yes    | yes      | no    |

Declarationsçš„ç»“æ„æ˜¯ `[declaration specifiers] [declarator]`

- [declaration specifiers]
  - type specifierï¼šåŸºæœ¬ç±»å‹ã€classã€templateç‰¹åŒ–ã€‚type specifierä¿®é¥°å…¶ä»–type specifier ï¼Œä»–ä»¬å…¨éƒ½è¢«é“¾æ¥åœ¨ä¸€èµ·ï¼Œé¡ºåºå¹¶ä¸é‡è¦ï¼ˆ`unsigned long` = `long unsigned`ï¼‰ã€‚
  - non-type specifier: storage class(`extern, static, thread_local`)ï¼Œfunction(`inline, virtual`)ï¼Œother(`friend, typedef`)ã€‚ä»–ä»¬ç›´æ¥åº”ç”¨åœ¨declarator-idä¸Šã€‚
  
  <div class="autocb" style="text-align:center;"><img src="./6.declarations.assets\autocb_0.png" style="zoom: 50%;box-shadow: rgba(0, 0, 0, 0.5) 10px 10px 10px; border-radius: 10px;" /></div>

- [declarator]
  - = declarator-id + (operators`*, &, &&, [], ()`)
  
    | ä¼˜å…ˆçº§  | operator               | å«ä¹‰                                               |
    | ------- | ---------------------- | -------------------------------------------------- |
    | Highest | `()`                   | grouping                                           |
    |         | `[]` <br> `()`         | "array"  <br>"function"                            |
    | Lowest  | `*` <br> `&` <br> `&&` | "pointer"  <br>"reference" <br> "rvalue reference" |




ä¸€ä¸ª**Declarations**æ˜¯ä»¥ä¸‹ä¸€ç§

- å‡½æ•°definition
- æ¨¡æ¿declaration(åŒ…æ‹¬éƒ¨åˆ†æ¨¡æ¿ç‰¹åŒ–Partial template specialization)
- æ˜¾å¼æ¨¡æ¿å®ä¾‹åŒ–
- æ˜¾å¼æ¨¡æ¿å…·ä½“åŒ–
- å‘½åç©ºé—´definition
- é“¾æ¥è§„èŒƒ
- å±æ€§declaration(attr) [C++11]
- ç©ºdeclarationï¼›
- ä¸€ä¸ªæ²¡æœ‰decl-specifier-seqçš„å‡½æ•°declaration


# 2. Specifiers

## const/volatile(cv type qualifiers) + mutable

### 1. cv type qualifiers åŸºæœ¬å«ä¹‰

- const å¯¹è±¡ï¼š**ä¸èƒ½è¢«ä¿®æ”¹**ï¼šè¯•å›¾ç›´æ¥è¿™æ ·åšæ˜¯ä¸€ä¸ªç¼–è¯‘æ—¶é”™è¯¯ï¼Œè¯•å›¾é—´æ¥è¿™æ ·åšï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡å¯¹éå¸¸é‡ç±»å‹çš„å¼•ç”¨æˆ–æŒ‡é’ˆæ¥ä¿®æ”¹å¸¸é‡å¯¹è±¡ï¼‰ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚
- volatile å¯¹è±¡ï¼švolatileæé†’ç¼–è¯‘å™¨å®ƒåé¢æ‰€å®šä¹‰çš„å˜é‡éšæ—¶éƒ½æœ‰å¯èƒ½æ”¹å˜ï¼Œå› æ­¤ç¼–è¯‘åçš„ç¨‹åºæ¯æ¬¡éœ€è¦å­˜å‚¨æˆ–è¯»å–è¿™ä¸ªå˜é‡çš„æ—¶å€™ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨å¯¹è¯¥å˜é‡ä¸åšä¼˜åŒ–ï¼Œéƒ½ä¼šç›´æ¥ä»å˜é‡å†…å­˜åœ°å€ä¸­è¯»å–æ•°æ®ï¼Œä»è€Œå¯ä»¥æä¾›å¯¹ç‰¹æ®Šåœ°å€çš„ç¨³å®šè®¿é—®ã€‚ä»»ä½•è¯•å›¾é€šè¿‡non-volatileç±»å‹çš„glvalueï¼ˆä¾‹å¦‚é€šè¿‡å¯¹non-volatileç±»å‹çš„å¼•ç”¨æˆ–æŒ‡é’ˆï¼‰æ¥è®¿é—®volatileå¯¹è±¡çš„è¡Œä¸ºéƒ½ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºã€‚ï¼ˆåµŒå…¥å¼ç¼–ç¨‹ç”¨çš„ï¼‰
- const-volatile å¯¹è±¡ï¼šæ—¢æ˜¯const å¯¹è±¡ï¼Œåˆæ˜¯volatile å¯¹è±¡ã€‚

### 2. åœ¨declaratorä¸­çš„ cv type qualifiers 

`const, volatile` æ˜¯å”¯äºŒä¸ªæ—¢å¯ä»¥ä½œä¸ºdeclaration specifiersï¼Œåˆå¯ä»¥ä½œä¸ºdeclaratorçš„ç¬¦å·ã€‚ä¾‹å¦‚`const int *v[N]` æˆ– `int const *v[N]` ä¸­ï¼Œ`const` éƒ½ä½œä¸ºtype specifierä¿®é¥° `int`ï¼Œå…¶ç»“æœæ˜¯â€œ`v` æ˜¯æœ‰ç€Nä¸ªæŒ‡é’ˆçš„æ•°ç»„ï¼ŒæŒ‡å‘å¯¹è±¡ä¸º`const int`â€ï¼›è€Œ `int * const v[N]` ä¸­`const` åœ¨declaratorä¸­å‡ºç°ï¼Œä¿®é¥° `*`ï¼Œå…¶ç»“æœæ˜¯â€œ`v` æ˜¯æœ‰ç€Nä¸ªæŒ‡é’ˆçš„`const`æ•°ç»„ï¼ŒæŒ‡å‘å¯¹è±¡ä¸º`int`â€ã€‚

```C++
widget * const cpw; // const pointer to ...
widget * const *pcpw; // pointer to const pointer to ...
widget ** const cpw; //const pointer to (non-const) pointer to ...
```

!!! note `const, volatile` æ”¾åœ¨å“ªå„¿ï¼Ÿ
    å…ˆå†™å…¶ä»–declarationçš„éƒ¨åˆ†ï¼Œç„¶åå°† `const, volatile` æ”¾åœ¨å¸Œæœ›è¢«ä¿®é¥°çš„type specifierçš„ **immediate right**ã€‚

### 3. mutable 

`mutable` å…è®¸ç±»ä¸­çš„æˆå‘˜å¯å˜ï¼Œå³ä½¿è¯¥objectè¢«å£°æ˜ä¸º`const`ã€‚


```C++
    const struct
    {
        int n1;
        mutable int n2;
    } x = {0, 0};        // const object with mutable member

//  x.n1 = 4; // error: member of a const object is const
    x.n2 = 4; // ok, mutable member of a const object isn't const
```


## constexpr

### 1. constexpr åŸºæœ¬å«ä¹‰

`constexpr`å®é™…ä¸Šå°±æ˜¯å°†è¿è¡Œæ—¶è®¡ç®—è½¬ç§»åˆ°**ç¼–è¯‘æœŸ**çš„æ–¹æ³•ã€‚


### 2. åœ¨ declarator ä¸­çš„ constexpr

`constexpr`çš„é¡ºåºæ¯”è¾ƒå¥‡æ€ªï¼Œå®ƒä¸æ˜¯ä¸€ä¸ªtype specifierï¼Œè¡Œä¸ºæ›´åƒnon-type specifierï¼ˆç›´æ¥ä¿®é¥°declarator-idï¼‰

<div class="autocb" style="text-align:center;"><img src="./6.declarations.assets\autocb_1.png" style="zoom: 50%;box-shadow: rgba(0, 0, 0, 0.5) 10px 10px 10px; border-radius: 10px;" /></div>

```C++
//non-equivalent 
char constexpr *p;
char const *p;

//equivalent 
char constexpr *p; // constexpr pointer to char 
char *const p;    // const pointer to char 
```


### ä¸åŒç‰ˆæœ¬

C++11ä¸‹ï¼Œ`constexpr`

- åªèƒ½æœ‰å•æ¡è¯­å¥
- `constexpr`æˆå‘˜å®ç°æ˜¯`const`çš„
- ä¸æ˜¯`non-virtual`çš„æˆå‘˜
- æ²¡æœ‰åˆ†æ”¯ã€switchç­‰è¿”å›

C++14ä¸‹ï¼Œ`constexpr`

- å¯ä»¥æœ‰å¤šæ¡è¯­å¥
- `constexpr`æˆå‘˜å¯ä»¥ä¸æ˜¯`const`çš„
- ä¸æ”¯æŒ`lambda`
- å›¾çµå®Œå¤‡

C++17ä¸‹ï¼Œ`constexpr`

- å¤šä¸ªstdlibæ”¯æŒ
- `lambda`è‡ªåŠ¨å¼€å¯`constexpr`

C++20ä¸‹ï¼Œ`constexpr`

- `constexpr` åŠ¨æ€åˆ†é…
- `constexpr` destructor/vector/string/algorithms

## constinit

## consteval

## Type alias, alias template

Type alias æ˜¯æŒ‡ä¸€ä¸ªå…ˆå‰å®šä¹‰çš„ç±»å‹çš„åç§°ï¼ˆç±»ä¼¼äº `typedef` ï¼‰ã€‚
Alias template æ˜¯æŒ‡ä¸€ä¸ªç±»å‹å®¶æ—çš„åç§°ã€‚

è¯­æ³•å¦‚ä¸‹

```C++
//type alias
using vec = std::vector;
using func = void (*)(int,int); //  = typedef void(*func)(int,int)

// alias template
template<class T>
using ptr = T*;

template<class CharT>
using mystring = std::basic_string<CharT, std::char_traits<CharT>>; // hide a template parameter

template<typename T>
struct Container { using value_type = T; };//introduce a member typedef name

template<typename ContainerT>
void info(const ContainerT& c)
{
    typename ContainerT::value_type T;
    std::cout << "ContainerT is `" << typeid(decltype(c)).name() << "`\n"
                 "value_type is `" << typeid(T).name() << "`\n";
}// generic programming
```

åœ¨é‡åˆ°templateå®šä¹‰çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨åšä¸¤æ®µå¤„ç†
    1. è§£æ template declarationï¼Œå¯¹æ¯ä¸ªtemplate åªå‘ç”Ÿä¸€æ¬¡ã€‚
    2. å½“å¯¹äºæŸä¸ªå‚æ•°ç»„åˆè¿›è¡Œå®ä¾‹åŒ–çš„æ—¶å€™ï¼Œå†ç‰¹åŒ–ä¸€ä¸ªç‰ˆæœ¬ã€‚


# 3. Specifiers


# 4. Declarator

## 4.1 Reference declaration

å°†ä¸€ä¸ªå‘½åçš„å˜é‡å£°æ˜ä¸ºä¸€ä¸ªå¼•ç”¨ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªå·²ç»å­˜åœ¨çš„å¯¹è±¡æˆ–å‡½æ•°çš„åˆ«åã€‚æœ‰å‡ ä¸ªè¦æ±‚
    - éœ€è¦è¢«åˆå§‹åŒ–ä¸ºåªæƒ³ä¸€ä¸ªåˆæ³•çš„å¯¹è±¡æˆ–å‡½æ•°
    - ä¸æŒ‡å‘ `void` å’Œå…¶ä»–references
    - æ²¡æœ‰é¡¶å±‚çš„ cv-qualifiersï¼Œå¹¶ä¸”å¦‚æœqualificationsè¢«åŠ åˆ°typedef-name / decltype specifier / type template parameterä¸Šï¼Œä¼šè¢«å¿½ç•¥ã€‚

```C++
& attr(optional) declarator(1)  //å·¦å€¼å¼•ç”¨
&& attr(optional) declarator(2) //å³å€¼å¼•ç”¨

```

**ğŸ”˜ å¼•ç”¨æŠ˜å **
å³å€¼å¼•ç”¨æŒ‡å‘å³å€¼å¼•ç”¨ -> æŠ˜å ä¸ºå³å€¼å¼•ç”¨ã€‚å…¶ä»–æ‰€æœ‰ç»„åˆéƒ½æŠ˜å ä¸ºå·¦å€¼å¼•ç”¨ã€‚

```C++
typedef int&  lref;
typedef int&& rref;
int n;
 
lref&  r1 = n; // type of r1 is int&
lref&& r2 = n; // type of r2 is int&
rref&  r3 = n; // type of r3 is int&
rref&& r4 = 1; // type of r4 is int&&
```

**ğŸ”˜ å·¦å€¼å¼•ç”¨**
**ğŸ”˜ å³å€¼å¼•ç”¨**
**ğŸ”˜ Forwardå¼•ç”¨**
è½¬å‘å¼•ç”¨å’Œå³å€¼å¼•ç”¨ä¸åŒçš„åœ°æ–¹åœ¨äºï¼šå®ƒ**ä¿ç•™äº†ä¸€ä¸ªå‡½æ•°å‚æ•°çš„å€¼ç±»åˆ«**ï¼Œä½¿å¾—é€šè¿‡`std::forward`è½¬å‘å®ƒæˆä¸ºå¯èƒ½ã€‚è½¬å‘å¼•ç”¨æ˜¯ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¹‹ä¸€ã€‚

1. ä¸€ä¸ªå‡½æ•°æ¨¡æ¿çš„å‡½æ•°å‚æ•°è¢«å£°æ˜ä¸ºå¯¹åŒä¸€å‡½æ•°æ¨¡æ¿çš„cv-unqualifiedç±»å‹æ¨¡æ¿å‚æ•°çš„**å³å€¼å¼•ç”¨**

    ```C++
    template<class T>
    int f(T&& x)                      // x is a forwarding reference
    {
        return g(std::forward<T>(x)); // and so can be forwarded
    }
    
    int main()
    {
        int i;
        f(i); // argument is lvalue, calls f<int&>(int&), std::forward<int&>(x) is lvalue
        f(0); // argument is rvalue, calls f<int>(int&&), std::forward<int>(x) is rvalue
    }
    
    template<class T>
    int g(const T&& x); // x is not a forwarding reference: const T is not cv-unqualified
    
    template<class T>
    struct A
    {
        template<class U>
        A(T&& x, U&& y, int* p); // x is not a forwarding reference: T is not a
                                // type template parameter of the constructor,
                                // but y is a forwarding reference
    };
    ```

2. `auto&&`ï¼Œé™¤äº†æ˜¯ä» `{}` åˆå§‹åŒ–åˆ—è¡¨æ¨æ–­å‡ºæ¥çš„æ—¶å€™

   ```C++
   auto&& vec = foo();       // foo() may be lvalue or rvalue, vec is a forwarding reference
    auto i = std::begin(vec); // works either way
    (*i)++;                   // works either way
    
    g(std::forward<decltype(vec)>(vec)); // forwards, preserving value category
    
    for (auto&& x: f())
    {
        // x is a forwarding reference; this is the safest way to use range for loops
    }
    
    auto&& z = {1, 2, 3}; // *not* a forwarding reference (special case for initializer lists)
   ```

!!! note å¦‚ä½•æ¨æ–­æ˜¯ forward-referenceè€Œä¸æ˜¯å³å€¼å¼•ç”¨
    1. `arg` ä¸æ˜¯ cv-qualifiedã€‚
    2. `arg` åœ¨ä¸€ä¸ª"deduction context"ä¸­ï¼ˆä¹Ÿå°±æ˜¯ç±»å‹`T`å¯èƒ½æ˜¯ä»ä¸€ä¸ªç±»å‹æ¨¡æ¿ä¸­æ¨æ–­å¾—åˆ°çš„ï¼‰ã€‚
    ```C++
    template <typename T>
    void dispatch(T && arg); // å¼•ç”¨è½¬å‘

    template <typename T>
    class C{
    public: 
        void mf(T &&x); // å³å€¼è½¬å‘ï¼ŒCåˆ›å»ºæ—¶Tå°±å®šäº†
    };
    ```




# 5. Block declarations