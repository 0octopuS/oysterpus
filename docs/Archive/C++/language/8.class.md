# 1. Class general

## 1.1 Overview

### 1.1.1 Class åŸºæœ¬ä»‹ç»

ä¸€ä¸ªç±»æ˜¯ä¸€ä¸ªç”¨æˆ·å®šä¹‰çš„ç±»å‹

**ğŸ”˜æˆå‘˜ç»„æˆ**
æˆå‘˜åœ¨ definition çš„æ—¶å€™å°±å®šäº†ï¼Œä¸èƒ½åƒ namespace ä¸€æ ·åè¡¥ã€‚

1. æ•°æ®æˆå‘˜ï¼ˆa. non-static b. staticï¼‰
2. æˆå‘˜å‡½æ•°ï¼ˆa. non-static b. staticï¼‰
3. nested ç±»å‹ï¼ˆa. ç±»ä¸­æœ‰ nested ç±»æˆ– enumeration b. ä½¿ç”¨ typedef æˆ– type alias å®šä¹‰çš„ç±»å‹åˆ«å c. [injected-class-name](#14-injected-class-name)ï¼‰
4. ä»ç±»ä¸­å®šä¹‰çš„ä»»ä½• unscoped çš„ enumerations é‡Œå¾—åˆ°çš„ enumeratorsï¼Œæˆ–è€…æ˜¯ä½¿ç”¨ using-declarations / using-enum-declarations å¼•å…¥çš„æˆå‘˜ã€‚
5. æˆå‘˜æ¨¡æ¿ï¼ˆvariable æ¨¡æ¿ï¼Œç±»æ¨¡æ¿æˆ–å‡½æ•°æ¨¡æ¿ï¼‰å¯èƒ½ä¼šåœ¨ä»»ä½• non-local class/struct/union çš„ä¸»ä½“ä¸­å‡ºç°ã€‚

**ğŸ”˜å¤šæ€**
å£°æ˜/ç»§æ‰¿äº† virtual æˆå‘˜å‡½æ•°çš„ class è¢«ç§°ä¸º polymorphic ï¼ˆå¤šæ€ï¼‰ã€‚è¿™ç§ç±»å‹çš„ objects å°±æ˜¯å¤šæ€ objectsï¼Œ æœ‰ä½œä¸ºå¯¹è±¡è¡¨ç¤ºçš„ä¸€éƒ¨åˆ†è€Œå­˜å‚¨çš„è¿è¡Œæ—¶ç±»å‹ä¿¡æ¯ï¼Œè¿™å¯ä»¥ç”¨ `dynamic_cast` å’Œ `typeid` æ¥æŸ¥è¯¢ã€‚è™šæ‹Ÿæˆå‘˜å‡½æ•°å‚ä¸åŠ¨æ€ç»‘å®šã€‚

**ğŸ”˜æŠ½è±¡ç±»**
ä¸€ä¸ªè‡³å°‘æœ‰ä¸€ä¸ªå£°æ˜æˆ–ç»§æ‰¿çš„çº¯è™šæ‹Ÿæˆå‘˜å‡½æ•°çš„ç±»æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ã€‚è¿™ç§ç±»å‹çš„å¯¹è±¡ä¸èƒ½è¢«åˆ›å»ºã€‚

**ğŸ”˜LiteralType**
ä¸€ä¸ªå…·æœ‰ constexpr æ„é€ å‡½æ•°çš„ç±»æ˜¯ä¸€ä¸ª LiteralType ï¼šè¿™ç§ç±»å‹çš„å¯¹è±¡å¯ä»¥åœ¨ç¼–è¯‘æ—¶è¢« constexpr å‡½æ•°æ“ä½œã€‚

### 1.1.1 Classes çš„æ€§è´¨

**ğŸ”˜ Trivially copyable class**
è‡³å°‘æœ‰ä¸€ä¸ªåˆæ³•çš„ copy/move constructor/assignment ï¼Œ å¹¶ä¸”è¦æ±‚æ‹¥æœ‰çš„ copy/move constructor/assignment å’Œ destructor éƒ½æ˜¯ trivial çš„ï¼Œä¸”destructor ä¸èƒ½æ˜¯ deletedã€‚

**ğŸ”˜ Trivial class**
åœ¨ Trivially copyable çš„åŸºç¡€ä¸Šï¼Œæœ‰1ä¸ªæˆ–æ›´å¤šçš„ default constructorï¼Œå¹¶ä¸”æ¯ä¸ªéƒ½æ˜¯ trivial çš„ã€‚

**ğŸ”˜ Standard-layout class/struct/union**
Standard-layout class/struct/union éœ€è¦æ»¡è¶³ä»¥ä¸‹å‡ æ¡æ€§è´¨ï¼š

**ğŸ”˜ Implicit-lifetime class**
æ˜¯aggregateçš„ï¼Œå¹¶ä¸”destructorä¸æ˜¯ç”¨æˆ·æä¾›çš„ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªtrivial constructorå’Œä¸€ä¸ª trivial non-deleted destructorã€‚

**ğŸ”˜ POD class(C++20ä»¥åé™çº§)**
æ˜¯ä¸€ä¸ªtrivial class +  standard-layout classï¼Œå¹¶ä¸”æ²¡æœ‰ non-static çš„æ•°æ®æˆå‘˜çš„ç±»å‹æ˜¯ non-POD ç±»ã€‚

1. æ²¡æœ‰ non-static æ•°æ®æˆå‘˜çš„ç±»å‹æ˜¯ non-standard-layout çš„ç±»æˆ–å¼•ç”¨
2. æ²¡æœ‰ virtual å‡½æ•°å’Œ virtual åŸºç±»
3. å¯¹ä»»ä½• non-static æ•°æ®æˆå‘˜ æœ‰ç€åŒæ ·çš„è®¿é—®æ§åˆ¶
4. æ²¡æœ‰ non-standard-layout åŸºç±»
5. ç»§æ‰¿çš„ç±»ä¸­åªæœ‰ä¸€ä¸ªæœ‰ non-static æ•°æ®æˆå‘˜
6. æ²¡æœ‰ä¸€ä¸ªåŸºç±»çš„ç±»å‹ä¸ç¬¬ä¸€ä¸ª non-static æ•°æ®æˆå‘˜ç›¸åŒ


## 1.2 Class/Struct type

ä¸€ä¸ªç±»çš„ç±»å‹æ˜¯ç”±class-specifierå®šä¹‰çš„ï¼Œå®ƒå‡ºç°åœ¨å£°æ˜è¯­æ³•çš„decl-specifier-seqä¸­ã€‚å…³äºclass-specifierçš„è¯­æ³•ï¼Œè¯·å‚è§ç±»å£°æ˜ã€‚

## 1.3 Union type

## 1.4 Injected-class-name

# 2. Members

## 2.3 Nested classes

å£°æ˜åœ¨å¦ä¸€ä¸ª class ä¸­çš„ class/struct/union å«åš nested classã€‚

**ğŸ”˜ name lookup å’Œé—­åŒ…è®¿é—®**
nested class çš„ name å­˜åœ¨äºæŸä¸ªå°é—­çš„classä¸­ï¼Œname lookup æŸä¸ªnested classä¸­çš„æˆå‘˜å‡½æ•°å°†ä¼šåœ¨é¦–å…ˆæ£€éªŒ nested class çš„ scopeï¼Œç„¶åæ£€éªŒ enclosing class çš„scopeã€‚nested class å¯ä»¥è®¿é—® enclosing class ä¸­çš„æ‰€æœ‰æˆå‘˜ï¼Œä½†æ˜¯å®ƒåœ¨å…¶ä»–æ–¹é¢æ˜¯ç‹¬ç«‹çš„ï¼Œå¯¹ enclosing class çš„thisæŒ‡é’ˆæ²¡æœ‰ç‰¹æ®Šè®¿é—®æƒã€‚nested classä¸­çš„å£°æ˜å¯ä»¥ä½¿ç”¨ enclosing class çš„ä»»ä½•æˆå‘˜ï¼Œéµå¾ªéé™æ€æˆå‘˜çš„é€šå¸¸ä½¿ç”¨è§„åˆ™ã€‚

```C++
int x,y; // å…¨å±€å˜é‡
class enclose // enclosing class
{
    // note: private members
    int x;
    static int s;
public:
    struct inner // nested class
    {
        void f(int i)
        {
            x = i; // Error: åœ¨æ²¡æœ‰å®ä¾‹çš„æƒ…å†µä¸‹ï¼Œä¸èƒ½å†™  non-static enclose::x
            int a = sizeof x; // Error until C++11,
                              // OK in C++11: operand of sizeof is unevaluated,
                              // this use of the non-static enclose::x is allowed.
            s = i;   // OK: can assign to the static enclose::s
            ::x = i; // OK: can assign to global x
            y = i;   // OK: can assign to global y
        }
 
        void g(enclose* p, int i)
        {
            p->x = i; // OK: æœ‰å®ä¾‹çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥assign to enclose::x
        }
    };
};
```


# 3. Special member functions

## Constructor / Destructor

!!! quote Guideline
    1. è€ƒè™‘Rule of 3ï¼šå½“éœ€è¦ä¸€ä¸ªdestructorçš„æ—¶å€™ï¼Œå¤§æ¦‚ç‡ä¹Ÿéœ€è¦ä¸€ä¸ªcopy constructorå’Œä¸€ä¸ªcopy assignment operatorã€‚(outdate since C++11?)
    2. è€ƒç•¥Rule of 5ï¼šå½“éœ€è¦ä¸€ä¸ªdestructorçš„æ—¶å€™ï¼Œå¤§æ¦‚ç‡ä¹Ÿéœ€è¦ä¸€ä¸ªcopy/move constructorå’Œä¸€ä¸ªcopy/move assignment operatorã€‚
    3. <span id="rule0">è€ƒè™‘Rule of 0 </span>ï¼šä¸éœ€è¦æ˜¾å¼destructorã€copy constructorå’Œcopy assignment çš„ç±»æ›´å®¹æ˜“å¤„ç†ã€‚ï¼ˆåªè¦æˆå‘˜éƒ½èƒ½é“¾å¼å¤„ç†ï¼Œåˆ«ç”¨raw pointers!ï¼‰
    4. å¦‚æœå®šä¹‰æˆ–è€…`=delete`ä»»ä½•é»˜è®¤æ“ä½œï¼Œé‚£ä¹ˆå°±å…¨éƒ¨å®šä¹‰æˆ–è€…å…¨éƒ¨`=delete`ã€‚
    5. å¦‚æœæƒ³è¦ default/delete move operationï¼Œé‚£ä¹ˆè¯·è·ŸéšRule of 5ã€‚
    6. å¦‚æœæƒ³è¦copyå–ä»£ä»»ä½•moveï¼Œè¯·è·ŸéšRule of 3ï¼ˆè¿™ä¸‰ä¸ªdefaultä»¥åï¼Œmoveä¼šè¢«æ˜¾å¼å¿½ç•¥ï¼‰ã€‚

### 1. Default constructor

é»˜è®¤æ„é€ å‡½æ•°æ˜¯ä¸€ä¸ª**å¯ä»¥åœ¨æ²¡æœ‰å‚æ•°çš„æƒ…å†µä¸‹**è¢«è°ƒç”¨çš„æ„é€ å‡½æ•°ï¼ˆè¦ä¹ˆç”¨ä¸€ä¸ªç©ºçš„å‚æ•°åˆ—è¡¨å®šä¹‰ï¼Œè¦ä¹ˆä¸ºæ¯ä¸ªå‚æ•°æä¾›é»˜è®¤å‚æ•°ï¼‰ã€‚ä¸€ä¸ªå…·æœ‰å…¬å…±é»˜è®¤æ„é€ å‡½æ•°çš„ç±»å‹è¢«ç§°ä¸º`DefaultConstructible`ã€‚

**ğŸ”˜ ç¼–è¯‘å™¨ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•°**
å¦‚æœä¸€ä¸ªclassä¸­æ²¡æœ‰å®šä¹‰æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°†è‡ªå·±åˆ›å»ºä¸€ä¸ªé»˜è®¤constructorã€‚
ä½†æ˜¯åªè¦å®šä¹‰äº†**ä»»ä½•ä¸€ä¸ªæ„é€ å‡½æ•°**ï¼Œæˆ–è€…ä»»ä½•æ•°æˆå‘˜åŠå…¶åŸºç±»ä¸æ˜¯é»˜è®¤æ„é€ çš„ï¼Œç¼–è¯‘å™¨å°±å°†ä¸ä¼šè‡ªå·±ç”Ÿæˆä»»ä½•æ„é€ å‡½æ•°ã€‚
**ğŸ”˜ æ˜¾å¼å£°æ˜=default**
æ˜¾å¼å£°æ˜è®©ç¼–è¯‘å™¨ç»™å‡ºé»˜è®¤æ„é€ å‡½æ•°çš„è¯­æ³•å¦‚ä¸‹ï¼Œè¿™ç®—æ˜¯ä¸€ä¸ªdefinitionã€‚é™¤äº†é»˜è®¤åˆå§‹åŒ–ä»¥å¤–ï¼Œå¯èƒ½è¿˜ä¼šç»™ä½ ä¸€äº›å…¶ä»–æ•ˆæœï¼Œä¾‹å¦‚`noexcept`ã€‚

!!! quote Guideline
    é¿å…è‡ªå·±å†™empty default constructorï¼Œæœ€å¥½ä½¿ç”¨ `=default`ã€‚

```C++
Widget()=default;
```

**ğŸ”˜ Member Initializer List**
åœ¨è¿›å…¥æ„é€ å‡½æ•°ä¹‹å‰ï¼Œæœ‰ä¸€ä¸ªæˆå‘˜åˆå§‹åŒ–åˆ—è¡¨ã€‚
å¦‚æœè¦åˆå§‹åŒ–æˆå‘˜åº”è¯¥åœ¨è¿™é‡Œï¼Œè€Œä¸æ˜¯åœ¨æ„é€ å‡½æ•°ä¸­ä½¿ç”¨èµ‹å€¼è¡¨è¾¾å¼ã€‚

```C++
Widget()ï¼š s{"CppCon"}, i = 1 ,pi = nullptr{}
```

!!! Quote Core Guidline
    C.47ï¼šæŒ‰ç…§æˆå‘˜declarationçš„é¡ºåºæ¥çºªè¿›è¡Œåˆå§‹åŒ–ã€‚
    C.49ï¼šåœ¨æ„é€ å‡½æ•°é‡Œï¼Œé€‰æ‹©initializationè€Œä¸æ˜¯èµ‹å€¼ã€‚

### 2. Destructor

æ¯ä¸ªclasséƒ½æœ‰destructorã€‚å’Œconstructorç±»ä¼¼ï¼Œå¦‚æœè‡ªå·±å£°æ˜äº†ä¸€ä¸ªï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°±ä¸ä¼šè¿›è¡Œé»˜è®¤ç”Ÿæˆã€‚
**ğŸ”˜ ç¼–è¯‘å™¨ç”Ÿæˆé»˜è®¤ææ„å‡½æ•°**
å°†ä¼šè°ƒç”¨æ‰€æœ‰æˆå‘˜çš„deconstructorï¼Œä½†æ˜¯å¯¹åŸºç¡€ç±»å‹ä¸åšä»»ä½•æ“ä½œã€‚

```C++
~Widget(){
    ~delete pr; // éœ€è¦æ‰‹åŠ¨åˆ é™¤ï¼Œå¦åˆ™èµ„æºæ³„éœ²
}
```

!!! quote Guideline
    1. å¦‚æœä»»ä½•ææ„å™¨å¯¹ä»»ä½•æˆå‘˜çš„èµ„æºé‡Šæ”¾è´Ÿè´£ï¼Œé‚£ä¹ˆéœ€è¦æ‰‹åŠ¨å†™ä¸€ä¸ªdestructorã€‚
    2. æ°¸è¿œä¸è¦è‡ªå·±å†™ä¸€ä¸ªç©ºdestructorï¼Œå¯ä»¥ç”¨`=default`.

### 3. Copy constructor/assignment

Copy constructorçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ `(const)(volatile) T&`ï¼Œå…¶ä»–å‚æ•°è¦ä¹ˆä¸ºç©ºï¼Œè¦ä¹ˆæœ‰é»˜è®¤å€¼ã€‚

```C++
Widget (Widget const&) ; // The default
Widget (Widget&); // Possible, but very likely not reasonable
Widget (Widget);  // Not possible; recursive call 
```

Copy assignmentçš„å‚æ•°ä¹Ÿç±»ä¼¼ã€‚

```C++
Widget& operator= (Widget const&) ; // The default
Widget& operator= (Widget&); // Possible, but very likely not reasonable
Widget& operator= (Widget);  // Reasonable builds on the copy constructor 
```

**ğŸ”˜ ç¼–è¯‘å™¨ç”Ÿæˆcopy constructor**
ç¼–è¯‘å™¨**æ€»æ˜¯**ä¼šè‡ªåŠ¨ç”Ÿæˆcopy constructorï¼Œé™¤éæ˜¾å¼å£°æ˜copy/move constructorï¼Œæˆ–è€…æœ‰ä»»ä½•æ•°æ®æˆå‘˜æ˜¯ä¸å¯å¤åˆ¶çš„ã€‚

!!! quote Guideline
    æ¯ä¸ªclasséƒ½æœ‰copy constructorå’Œcopy assignmentæ“ä½œã€‚copyæ“ä½œè¦ä¹ˆæ˜¯å¯ç”¨çš„ï¼Œè¦ä¹ˆæ˜¯(éšå¼)åˆ é™¤çš„ã€‚
**ğŸ”˜ =delete**
**=delete**å¹¶ä¸æ˜¯çœŸæ­£åˆ é™¤ï¼Œè¿™ç®—æ˜¯ä¸€ä¸ªdefinitionã€‚åªæ˜¯å¯¹ä»–è¿›è¡Œäº†ç¦ç”¨ã€‚å¦‚æœOverload resolutioné€‰ä¸­äº†copyæ“ä½œï¼Œé‚£ä¹ˆç¼–è¯‘å°†ä¼šå¤±è´¥ã€‚
**ğŸ”˜ é»˜è®¤copy constructorè¡Œä¸º**
é»˜è®¤copy constructorå°†ä¼šå¯¹æ¯ä¸ªæ•°æ®æˆå‘˜ä½¿ç”¨copyæ„é€ ã€‚

```C++
class Widget{
public:
    Widget(Widget const & other) 
        : Base{other}
        , i{other.i}
        , s{other.s}
        , pr{other.pr} {}
    Widget& operator=(Widget const& other){
        Base::operator=(other);
        i = other.i;
        s = other.s;
        pr = other.pr;
        return *this;
    }
private:
    int i; // a fundamental type
    std::string s; // a class(user-defined) type
    Resource* pr{}; // a possible resoure
}
```

**ğŸ”˜ é»˜è®¤copy constructorç¼ºç‚¹(shallow copy)**
å¯¹äºä¸Šé¢çš„`Resoure* pr{}`ï¼Œå¦‚æœä½¿ç”¨é»˜è®¤copyï¼Œé‚£ä¹ˆæ˜¾ç„¶åœ¨destructçš„æ—¶å€™ï¼Œè¿™ä¸ªèµ„æºå°†ä¼šè¢«**double delete**ã€‚
å› æ­¤è¿™ç®—æ˜¯ä¸€ç§shallow copyï¼Œåº”è¯¥å°½é‡ä½¿ç”¨deep copyã€‚

```C++
// Improve1 : new ptr
pr{other.pr ? new Resource{*other.pr}:nullptr} 
// Improve2 : å¯¹æ—§çš„èµ„æºåšé‡Šæ”¾
Widget& operator=(Widget const& other){
    delete resource; // åœ¨destructorä»¥å¤–åšé‡Šæ”¾ï¼Œå¯¼è‡´self-assignmenté—®é¢˜ï¼Œé€šå¸¸ç”¨if(this!=&other)æ£€æŸ¥
    pr(other.pr ? new Resource{*other.pr}:nullptr);
}
```

**ğŸ”˜ temporary-swap idiom**
å¯¹äºä¸Šé¢çš„`Resource`æŒ‡é’ˆï¼Œç®¡ç†èµ·æ¥æ¯”è¾ƒéº»çƒ¦ï¼Œå¯ä»¥ä½¿ç”¨temporary-swap idiomã€‚è¿™ä¸æ˜¯æœ€å¿«çš„æ–¹æ³•ï¼Œä½†æ˜¯å¾ˆç®€å•ã€‚

```C++
Widget& operator=(Widget const& other){
    Widget temp(other); // è°ƒç”¨ copy-constructorï¼Œæ¯”assignmenté è°±
    swap(temp);         // å’Œè‡ªèº«åšç½®æ¢ï¼Œtempä¸­çš„old resourceè¢«destructorå¤„ç†ï¼ˆå®‰å…¨ï¼
}
```

**ğŸ”˜ å¤„ç†resourceçš„æœ€ä¼˜æ–¹æ³•(check + swap)**
æ ¹æ®resourceçš„ä¸åŒçŠ¶æ€ï¼Œåˆ†ä¸ºèµ‹å€¼å’Œäº¤æ¢ä¸¤ç§ç±»å‹æ¥è¿›è¡Œå¤„ç†ã€‚

```C++
void swap(Widget& other){
    using std::swap;
    swap(id,other.id);
    swap(name.other.name);
    swap(resource,other.resource);
}
Widget& operator=(Widget const& other){
    if(pr && other.pr){       
        Base::operator=(other); // No need to handle self-assignment explicitly
        i = other.i;
        s = other.s;
        *pr = *other.pr; // copy assignment of the resource
    } else{
        Widget temp(other); // è°ƒç”¨ copy-constructorï¼Œæ¯”assignmenté è°±
        swap(temp);
    }
    return *this;
}
```

!!! quote Core Guideline
    C.83 å¯¹äºvalue-like ç±»å‹ï¼Œè€ƒè™‘æä¾›ä¸€ä¸ª`noexcept` äº¤æ¢å‡½æ•°ã€‚

**ğŸ”˜ å°†raw pointeriæ›¿æ¢æˆsmart pointer**
ä¸Šé¢æåˆ°çš„é—®é¢˜å…¶å®æ¥è‡ªäºraw pointerä¸å¯¹èµ„æºè¿›è¡Œé”€æ¯å¤„ç†ã€‚ä½¿ç”¨smart_pointerå°±æ²¡æœ‰è¿™ä¸ªé—®é¢˜ã€‚
å¦‚æœä½¿ç”¨unique_ptr(uncopyable)ï¼Œé‚£ä¹ˆæ•´ä¸ªç±»å°±ä¸èƒ½è¢«æ‹·è´ã€‚
è€Œä½¿ç”¨shared_ptrï¼Œé‚£ä¹ˆå°±ä¸ç”¨è‡ªå·±å†™copyæ“ä½œäº†ï¼Œç¼–è¯‘å™¨éƒ½å¯ä»¥è‡ªå·±ç”Ÿæˆã€‚ï¼ˆ[Rule of 0](#rule0)ï¼‰.

```C++
class Widget{
public:
    Widget(Widget const & other) 
        : Base{other}
        , i{other.i}
        , s{other.s}
        , pr{other.pr} {}
    Widget& operator=(Widget const& other){
        Base::operator=(other);
        i = other.i;
        s = other.s;
        pr = other.pr;
        return *this;
    }
private:
    int i; // a fundamental type
    std::string s; // a class(user-defined) type
    std::shared_ptr<Resource> pr{}; // ä¸éœ€è¦æ‰‹åŠ¨å†™destructoräº†ï¼Œspä¼šè´Ÿè´£æ¸…ç†
}
```


### 4. Move constructor

Move constructorçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ `(const)(volatile) T&&`ï¼Œå…¶ä»–å‚æ•°è¦ä¹ˆä¸ºç©ºï¼Œè¦ä¹ˆæœ‰é»˜è®¤å€¼ã€‚


```C++
Widget( Widget&& ) noexcept; // The default
Widget( Widget const &&) noexcept; // Possible, but uncommon

Widget& operator=( Widget &&) noexcept;// The default
Widget& operator=( Widget const &&) noexcept;// Possible, but uncommon
```

**ğŸ”˜ ç¼–è¯‘å™¨ç”Ÿæˆmove constructor**
å¦‚æœæ²¡ç”¨ç”¨æˆ·å®šä¹‰move constructor/assignmentã€copy constructor/assignmentã€destructorï¼Œå¹¶ä¸”æ‰€æœ‰æ•°æ®æˆå‘˜è¦ä¹ˆèƒ½copyè¦ä¹ˆèƒ½moveï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°†ä¼šè‡ªå·±ç”Ÿæˆmove constructorï¼Œç±»å‹ä¸º`T::T(T&&)`ã€‚

ä¸€ä¸ªç±»å¯ä»¥æœ‰å¤šä¸ªmove constructorï¼ˆeg: `T::T(T&&),T::T(const T&&)`ã€‚å¦‚æœç”¨æˆ·å®šä¹‰äº†move constructorï¼Œè¿˜æ˜¯å¯ä»¥ç”¨`=default`æ¥è¿«ä½¿ç¼–è¯‘å™¨ç”Ÿæˆé»˜è®¤moveã€‚

**ğŸ”˜ =delete**
**ğŸ”˜ é»˜è®¤move constructorè¡Œä¸º**

```CPP
class Widget{
public:
    Widget(Widget && other)noexcept
        : Base{std::mvoe(other)}
        , i{std::mvoe(other.i)}
        , s{std::mvoe(other.s)}
        , pr{std::mvoe(other.pr)} {}
    Widget& operator=(Widget&& other){
        Base::operator=(std::move(other));
        i = std::move(other.i);
        s = std::move(other.s);
        pr = std::move(other.pr);
        return *this;
    }
private:
    int i; // a fundamental type
    std::string s; // a class(user-defined) type
    Resource* pr{}; // a possible resoure
}
```

å’Œcopyä¸€æ ·æœ‰shallow moveçš„é—®é¢˜ï¼ŒåŒæ ·è¦ä½¿ç”¨

```C++
Widget temp(std:: move(other));
swap(temp);
```

!!! note ç¼–è¯‘å™¨ç”Ÿæˆç‰¹æ®Šæˆå‘˜å‡½æ•°çš„è§„å¾‹
    1. é™¤äº† `default ctor` ä»¥å¤–ï¼Œç”¨æˆ·ä»»æ„å®šä¹‰ä¸€ä¸ªï¼Œ`move` æ“ä½œéƒ½ä¸è‡ªåŠ¨ç”Ÿæˆäº†ã€‚
    2. ç”¨æˆ·å®šä¹‰äº† `move` æ“ä½œä»¥åï¼Œ`copy` æ“ä½œä¼šè¢« `delete` ï¼Œå˜æˆmove-onlyç±»å‹ã€‚
    3. `dtor` åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½ä¼šç”Ÿæˆã€‚

    <div class="autocb" style="text-align:center;"><img src="./8.class.assets\autocb_0.png" style="zoom: 50%;box-shadow: rgba(0, 0, 0, 0.5) 10px 10px 10px; border-radius: 10px;" /></div>


# 4. Inheritate



